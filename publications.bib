# Geoff Hulette's publications

@inproceedings{stego,
 author = {Hulette, Geoffrey C. and Solis, John},
 title = {On Source Code Transformations for Steganographic Applications},
 booktitle = {Proceedings of the 2011 IEEE/WIC/ACM International Conferences on Web Intelligence and Intelligent Agent Technology},
 series = {WI-IAT '11},
 year = {2011},
 isbn = {978-0-7695-4513-4},
 pages = {261--264},
 publisher = {IEEE Computer Society},
 address = {Washington, DC, USA},
 abstract = {The amount of publicly available source code on the Internet makes it attractive as a potential message carrier for steganographic applications. Unfortunately, it is often overlooked since embedding information in an undetectable way is challenging. We investigate term rewriting as a method for embedding messages into programs via transformations on source code. We elaborate on several possible transformation strategies and discuss how they might be applied in a steganographic setting. We continue with a discussion on (a) the implications and trade-offs of preserving semantic properties, (b) the relationship between messages and transformations, and (c) how to incorporate existing natural language processing techniques. The goal of this work is to elicit constructive feedback and present ideas that stimulate future work.}
}

@inproceedings{onramp,
 author = {Hulette, Geoffrey C. and Sottile, Matthew J. and Armstrong, Robert and Allan, Benjamin},
 title = {{OnRamp}: enabling a new component-based development paradigm},
 booktitle = {Proceedings of the 2009 Workshop on Component-Based High Performance Computing},
 series = {CBHPC '09},
 year = {2009},
 isbn = {978-1-60558-718-9},
 location = {Portland, Oregon},
 pages = {1--10},
 publisher = {ACM},
 address = {New York, NY, USA},
 abstract = {Often the adoption of component-based scientific software requires the developer to abandon comfortable practices and embrace an unfamiliar software methodology. OnRamp provides a mechanism for the developer to generate CCA components, through commented markup in their original software, and keep their familiar software development practices. The developer uses these annotations to identify which methods in their code belong to which Port interfaces, and which Ports belong to which CCA components. Taken by itself, the markup is sufficient to create a skeleton of components representing the exported functionality of the original code, but because the entire code is available to OnRamp the implementation can also be generated. The functionality of the original code is wrapped in annotation-specified components, exporting part or all of its original functionality. OnRamp provides a model for component software engineering that allows developers to improve their code with their familiar software and in their established software practices and also interoperate with external developers easily when the need arises.}
}

@inproceedings{lazy-workflow,
 author = {Sottile, Matthew J. and Hulette, Geoffrey C. and Malony, Allen D.},
 title = {Workflow representation and runtime based on lazy functional streams},
 booktitle = {Proceedings of the 4th Workshop on Workflows in Support of Large-Scale Science},
 series = {WORKS '09},
 year = {2009},
 isbn = {978-1-60558-717-2},
 location = {Portland, Oregon},
 pages = {1--10},
 articleno = {10},
 publisher = {ACM},
 address = {New York, NY, USA},
 abstract = {Workflows are a successful model for building both distributed and tightly-coupled programs based on a dataflow-oriented coordination of computations. Multiple programming languages have been proposed to represent workflow-based programs in the past. In this paper, we discuss a representation of workflows based on lazy functional streams implemented in the strongly typed language Haskell. Our intent is to demonstrate that streams are an expressive intermediate representation for higher-level workflow languages. By embedding our stream-based workflow representation in a language such as Haskell, we also gain with minimal effort the strong type system provided by the base language, the rich library of built-in functional primitives, and most recently, rich support for managing concurrency at the language level.}
} 

@inproceedings{wool,
 author = {Hulette, Geoffrey C. and Sottile, Matthew J. and Malony, Allen D.},
 title = {{WOOL}: A Workflow Programming Language},
 booktitle = {Proceedings of the 2008 Fourth IEEE International Conference on eScience},
 series = {ESCIENCE '08},
 year = {2008},
 isbn = {978-0-7695-3535-7},
 pages = {71--78},
 acmid = {1488865},
 publisher = {IEEE Computer Society},
 address = {Washington, DC, USA},
 abstract = {Workflows offer scientists a simple but flexible programming model at a level of abstraction closer to the domain-specific activities that they seek to perform. However, languages for describing workflows tend to be highly complex, or specialized towards a particular domain, or both. WOOL is an abstract workflow language with human-readable syntax, intuitive semantics, and a powerful abstract type system. WOOL workflows can be targeted to almost any kind of runtime system supporting data-flow computation. This paper describes the design of the WOOL language and the implementation of its compiler, along with a simple example runtime. We demonstrate its use in an image-processing workflow.}
} 
